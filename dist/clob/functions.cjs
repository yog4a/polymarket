"use strict";var l=Object.defineProperty;var N=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var B=Object.prototype.hasOwnProperty;var s=(e,r)=>l(e,"name",{value:r,configurable:!0});var z=(e,r)=>{for(var n in r)l(e,n,{get:r[n],enumerable:!0})},L=(e,r,n,t)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of P(r))!B.call(e,o)&&o!==n&&l(e,o,{get:()=>r[o],enumerable:!(t=N(r,o))||t.enumerable});return e};var M=e=>L(l({},"__esModule",{value:!0}),e);var W={};z(W,{OrderFunctions:()=>b});module.exports=M(W);var u=require("@polymarket/order-utils");var U={exchange:"0xdFE02Eb6733538f8Ea35D585af8DE5958AD99E40",negRiskAdapter:"0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296",negRiskExchange:"0xC5d563A36AE78145C45a50134d48A1215220f80a",collateral:"0x9c4e1703476e875070ee25b56a58b008cfb8fa78",conditionalTokens:"0x69308FB512518e39F9b16112fA8d994F4e2Bf8bB"},v={exchange:"0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E",negRiskAdapter:"0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296",negRiskExchange:"0xC5d563A36AE78145C45a50134d48A1215220f80a",collateral:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",conditionalTokens:"0x4D97DCd97eC945f40cF65F87097ACe5EA0476045"},A={"0.1":{price:1,size:2,amount:3},"0.01":{price:2,size:2,amount:4},"0.001":{price:3,size:2,amount:5},"0.0001":{price:4,size:2,amount:6}},O=s(e=>{switch(e){case 137:return v;case 80002:return U;default:throw new Error(`Invalid network: ${e}`)}},"getContractConfig");var g=class{constructor(r){this.cfg=r;let n=O(this.cfg.chainId);this.builderExchange=new u.ExchangeOrderBuilder(n.exchange,this.cfg.chainId,this.cfg.signer),this.builderNegRisk=new u.ExchangeOrderBuilder(n.negRiskExchange,this.cfg.chainId,this.cfg.signer)}static{s(this,"OrderBuilder")}builderExchange;builderNegRisk};var d=require("@polymarket/order-utils"),F=require("@polymarket/clob-client");var y=require("viem");var C=require("viem");var c=s(e=>{if(Number.isInteger(e))return 0;let r=e.toString().split(".");return r.length<=1?0:r[1].length},"decimalPlaces"),h=s((e,r)=>c(e)<=r?e:Math.round((e+Number.EPSILON)*10**r)/10**r,"roundNormal"),p=s((e,r)=>c(e)<=r?e:Math.floor(e*10**r)/10**r,"roundDown"),m=s((e,r)=>c(e)<=r?e:Math.ceil(e*10**r)/10**r,"roundUp"),x=s((e,r)=>{let n=parseFloat(r);return e>=n&&e<=1-n},"priceValid");function k(e,r,n,t){let o=h(n,t.price);if(e===d.Side.BUY){let a=p(r,t.size),i=a*o;return c(i)>t.amount&&(i=m(i,t.amount+4),c(i)>t.amount&&(i=p(i,t.amount))),{rawMakerAmt:i,rawTakerAmt:a,side:d.Side.BUY}}else if(e===d.Side.SELL){let a=p(r,t.size),i=a*o;return c(i)>t.amount&&(i=m(i,t.amount+4),c(i)>t.amount&&(i=p(i,t.amount))),{rawMakerAmt:a,rawTakerAmt:i,side:d.Side.SELL}}throw new Error(`Invalid side: ${e}`)}s(k,"getOrderRawAmounts");function f(e){return(0,C.parseUnits)(e.toString(),6).toString()}s(f,"toCollateralUnits");function E(e){let{signerAddress:r,makerAddress:n,userOrder:t,resolved:o}=e,a=e.signatureType??d.SignatureType.EOA;if(!x(t.price,o.tickSize))throw new Error(`invalid price (${t.price}), min: ${o.tickSize} - max: ${1-parseFloat(o.tickSize)}`);let i;typeof t.taker<"u"&&t.taker?i=t.taker:i=y.zeroAddress;let S=A[o.tickSize],{rawMakerAmt:T,rawTakerAmt:w,side:R}=k(t.side,t.size,t.price,S),I=f(T),D=f(w);return{maker:n,taker:i,tokenId:t.tokenID,makerAmount:I,takerAmount:D,side:R,feeRateBps:(o.feeRateBps??"0").toString(),nonce:(t.nonce??"0").toString(),signer:r,expiration:(t.expiration??0).toString(),signatureType:a}}s(E,"buildUnsignedOrder");var b=class{constructor(r,n,t,o,a){this.funderAddress=r;this.signerWallet=n;this.chainId=t;this.signatureType=o;this.getClobClient=a;this.signerAddress=this.signerWallet.address,this.orderBuilder=new g({signer:this.signerWallet,chainId:this.chainId})}static{s(this,"OrderFunctions")}signerAddress;orderBuilder;async createSignedOrder(r,n){let t=E({signerAddress:this.signerAddress,makerAddress:this.funderAddress,signatureType:this.signatureType,userOrder:r,resolved:n});return n.negRisk?this.orderBuilder.builderNegRisk.buildSignedOrder(t):this.orderBuilder.builderExchange.buildSignedOrder(t)}async postSignedOrder(r,n,t){return(await(await this.getClobClient()).postOrders([r],n,t))[0]}async postSignedOrders(r,n,t){return await(await this.getClobClient()).postOrders(r,n,t)}};0&&(module.exports={OrderFunctions});
